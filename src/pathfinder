#!/usr/bin/env python
# Pathfinding node.
# This will listen for new data from ORB_SLAM2 et al and
# rebroadcast messages containing the shortest path.

import rospy
from std_msgs.msg import String
from nav_msgs.msg import OccupancyGrid, Path, MapMetaData
from geometry_msgs.msg import PoseStamped
from pathfinding.core.diagonal_movement import DiagonalMovement
from pathfinding.core.grid import Grid
from pathfinding.finder.a_star import AStarFinder


class Pathfinder:

	def __init__(self):
		self.occupancy_grid = None #Last occupancy grid received from Octomap
		self.navmatrix = [] #2D map
		self.cam_pose = None #PoseStamped of camera position
		self.cam_grid_loc = () #x,y tuple of camera location on grid
		self.path = [] #Path
		self.loc = () #x,y tuple
		self.target = () #x,y tuple

		self.ros_path = Path()
		self.pub = rospy.Publisher('path', Path, latch=True, queue_size=10)
		rospy.Subscriber('projected_map', OccupancyGrid, self.listen_grid)
		rospy.Subscriber('orb_slam2_mynteye_s_stereo/pose', PoseStamped, self.listen_position)
		rospy.spin()


	def find_path(self, loc, target):
		# Takes the 2D map and plots a path from the current location to the target
		# Since self.path is a list, we can pop nodes off of it as we travel to them
		grid = Grid(matrix=self.navmatrix)
		start = grid.node(loc[0], loc[1])
		end = grid.node(target[0], target[1])
		finder = AStarFinder(diagonal_movement=DiagonalMovement.always)
		path, runs = finder.find_path(start, end, grid)
		path.reverse() #Put nodes into driving order
		if len(path) > 0: path.pop() #Remove the starting node we're in
		self.path = path
		rospy.loginfo(grid.grid_str(path=self.path, start=start, end=end))
		#publish_path(path)


	def unpack_navmatrix(self, data):
		# Turn OccupancyGrid into list of python lists
		meta = data.info
		self.navmatrix = [data.data[i:i+meta.width] for i in range(0, len(data.data), meta.width)]
		rospy.loginfo("MAP: w: {}, h: {}, res: {}".format(meta.width, meta.height, meta.resolution))
		

	def publish_path(self, path):
		# Format the list into an ROS Path message and publish
		self.ros_path = Path()
		
		for node in path:
			pose = PoseStamped()
			pose.pose.position.x = node.x
			pose.pose.position.y = node.y
			pose.pose.position.z = 0
			pose.pose.orientation.x = float(0)
			pose.pose.orientation.y = float(0)
			pose.pose.orientation.z = float(0)
			pose.pose.orientation.w = float(0)
			self.ros_path.poses_append(pose)
			
		self.pub.publish(self.ros_path)


	def listen_grid(self, data):
		# Listen to octomap_server for an OccupancyGrid
		rospy.loginfo("Pathfinder received data from Octomap server.")
		self.occupancy_grid = data
		self.unpack_navmatrix(data)
		# Run find_path()


	def listen_position(self, data):
		# Listen to orb_slam2 for the current camera position
		# Don't process position until grid has been received
		if self.occupancy_grid is None:
			return
		self.cam_pose = data
		origin = self.occupancy_grid.info.origin
		res = self.occupancy_grid.info.resolution
		x = (data.pose.position.x - origin.position.x) // res
		y = (data.pose.position.y - origin.position.y) // res
		self.cam_grid_loc = (x,y)
		rospy.loginfo("POS:: x: {}, y: {}".format(x,y))



if __name__ == '__main__':
	try:
		rospy.init_node('pathfinder')
		Pathfinder()
	except rospy.ROSInterruptException:
		pass
	
